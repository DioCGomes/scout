name: Release

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  packages: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Get latest tag
        id: get_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0") # v0.0.0 if none exists
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Calculate next version
        id: next_version
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          
          VERSION=${LATEST_TAG#v} # remove v prefix
          
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            BUMP_TYPE="${{ github.event.inputs.version_bump }}"
          else
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s") # get commits since last tag or all commits if no tag
            
             # determine bump type from commit messages using conventional commits
             # major: "type!:" or "BREAKING CHANGE" in commit
             # minor: "feat:" or "feat(scope):"
             # patch: everything else
             if echo "$COMMITS" | grep -qE "^[a-z]+(\(.+\))?!:|BREAKING CHANGE:"; then
              BUMP_TYPE="major"
            elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
              BUMP_TYPE="minor" # feat(...):
            else
              BUMP_TYPE="patch"
            fi
          fi
          
          echo "Bump type: $BUMP_TYPE"
          
          # Calculate new version
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          
          # Generate changelog from commits
          echo "## What's Changed" > RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          
          # Get commits since last tag (or all commits if no tag)
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s (%h)" 2>/dev/null)
          else
            COMMITS=$(git log --pretty=format:"- %s (%h)")
          fi
          
          # Categorize commits by conventional commit type (only write categories with content)
          FEATS=$(echo "$COMMITS" | grep -E "^- feat(\(.+\))?!?:" 2>/dev/null || true)
          FIXES=$(echo "$COMMITS" | grep -E "^- fix(\(.+\))?!?:" 2>/dev/null || true)
          DOCS=$(echo "$COMMITS" | grep -E "^- docs(\(.+\))?!?:" 2>/dev/null || true)
          MAINTENANCE=$(echo "$COMMITS" | grep -E "^- (chore|refactor|style|test|ci|build)(\(.+\))?!?:" 2>/dev/null || true)
          OTHER=$(echo "$COMMITS" | grep -vE "^- (feat|fix|docs|chore|refactor|style|test|ci|build)(\(.+\))?!?:" 2>/dev/null || true)
          
          if [ -n "$FEATS" ]; then
            echo "### Features" >> RELEASE_NOTES.md
            echo "$FEATS" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
          fi
          
          if [ -n "$FIXES" ]; then
            echo "### Bug Fixes" >> RELEASE_NOTES.md
            echo "$FIXES" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
          fi
          
          if [ -n "$DOCS" ]; then
            echo "### Documentation" >> RELEASE_NOTES.md
            echo "$DOCS" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
          fi
          
          if [ -n "$MAINTENANCE" ]; then
            echo "### Maintenance" >> RELEASE_NOTES.md
            echo "$MAINTENANCE" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
          fi
          
          if [ -n "$OTHER" ]; then
            echo "### Other Changes" >> RELEASE_NOTES.md
            echo "$OTHER" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
          fi
          
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$LATEST_TAG...$NEW_VERSION" >> RELEASE_NOTES.md
          
          cat RELEASE_NOTES.md

      - name: Update CHANGELOG.md
        run: |
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          DATE=$(date +%Y-%m-%d)
          
          # Create new changelog entry
          echo "# Changelog" > CHANGELOG_NEW.md
          echo "" >> CHANGELOG_NEW.md
          echo "All notable changes to Scout will be documented in this file." >> CHANGELOG_NEW.md
          echo "" >> CHANGELOG_NEW.md
          echo "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)," >> CHANGELOG_NEW.md
          echo "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)." >> CHANGELOG_NEW.md
          echo "" >> CHANGELOG_NEW.md
          echo "## [$NEW_VERSION] - $DATE" >> CHANGELOG_NEW.md
          echo "" >> CHANGELOG_NEW.md
          cat RELEASE_NOTES.md | tail -n +2 >> CHANGELOG_NEW.md
          echo "" >> CHANGELOG_NEW.md
          
          # Append existing changelog (if exists, skip header)
          if [ -f CHANGELOG.md ]; then
            # Skip the header lines from existing changelog and append
            tail -n +8 CHANGELOG.md >> CHANGELOG_NEW.md 2>/dev/null || true
          fi
          
          mv CHANGELOG_NEW.md CHANGELOG.md

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit changelog
        run: |
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          git add CHANGELOG.md
          git commit -m "chore(release): update changelog for $NEW_VERSION [skip ci]" || echo "No changes to commit"
          git push

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: '~> v2'
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: docker_meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}},value=${{ steps.next_version.outputs.new_version }}
            type=raw,value=latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.docker_meta.outputs.tags }}
          labels: ${{ steps.docker_meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.next_version.outputs.new_version }}

